import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';
import { RootState, AppThunk } from '../../../app/store';
import playerClient from '../../../api/playerClient';
import Model from '../../../models/api/Model';
import Constants from "../../../utils/Constants";
import Player from "../../../models/Entities/Player"

export interface playerState {
  records: Player[];
  selectedRecords: Player[];
  formDefaultModel: Player,
  status: 'idle' | 'loading' | 'failed' | 'notFetched',
  filter:{
    [key:string]:any,
    global?: string,
    name?: string,
    surname?: string,
    nickname?: string,
    description?: string,
  }
}

const initialState: playerState = {
  records: [],
  selectedRecords: [],
  formDefaultModel: { id: Constants.GUID_EMPTY},
  status: 'notFetched',
  filter: {
    global: "",
    name: "",
    surname: "",
    nickname: "",
    description: "",
  }
};

export const fetchAsync = createAsyncThunk(
  'player/fetch',
  async () => {
    try{
      const response = await playerClient.getAll({});
      // The value we return becomes the `fulfilled` action payload
      return response.data;
    }
    catch(exception){
      return null;
    }
  }
);

export const getByIdAsync = createAsyncThunk(
  'player/getById',
  async (id: string) => {
    try{
      const response = await playerClient.getById(id);
      // The value we return becomes the `fulfilled` action payload
      return response.data;
    }
    catch(exception){
      return null;
    }
  }
);

export const createAsync = createAsyncThunk(
  'player/create',
  async (payload: any) => {
    try{
      payload.image = payload.imagePath;
      const response = await playerClient.create(payload);
      // The value we return becomes the `fulfilled` action payload

      return response.data;
    }
    catch(exception){
      return null;
    }
  }
);

export const getFormDefaultModelAsync = createAsyncThunk(
  'player/getFormDefaultModel',
  async () => {
    try{
      const response = await playerClient.getFormDefaultModel();
      // The value we return becomes the `fulfilled` action payload
      return response.data;
    }
    catch{
      return null;
    }
  }
)


export const updateAsync = createAsyncThunk(
  'player/update',
  async (payload: any) => {
    try{
      const response = await playerClient.update(payload);
      // The value we return becomes the `fulfilled` action payload
      return response.data;
    }
    catch(exception){
      return null;
    }
  }
);

export const deleteAsync = createAsyncThunk(
  'player/delete',
  async (payload: any) => {
    try{
      await playerClient.delete(payload);
      // The value we return becomes the `fulfilled` action payload
      return payload;
    }
    catch(exception){
      return null;
    }
  }
);

export const playerSlice = createSlice({
  name: 'player',
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    addSelectedRecord: (state, action: PayloadAction<Player>) => {
      state.selectedRecords.push(action.payload);
    },
    delSelectedRecord: (state, action: PayloadAction<Player>) => {
      state.selectedRecords = state.selectedRecords.filter(x=> x.id !== action.payload.id);
    },
    clearSelectedRecords: (state) => {
      state.selectedRecords = [];
    },
    setFilter: (state, action: PayloadAction<{field: string, value: any}>) => {
      state.filter[action.payload.field] = action.payload.value;
    }
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    //fetch
    builder
      .addCase(fetchAsync.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(fetchAsync.fulfilled, (state, action) => {
        if(action.payload !== null){
          state.status = 'idle';
          state.records = action.payload;
        }
        else{
          state.status = 'failed'
        }
      });

    //getById
    builder
      .addCase(getByIdAsync.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(getByIdAsync.fulfilled, (state, action) => {
        if(action.payload !== null){
          state.status = 'idle';
          state.records = state.records.filter(x => x.id !== action.payload.id);
          
          state.records.push(action.payload);
          state.selectedRecords.push(action.payload);
        }
        else{
          state.status = 'failed'
        }
      });

    //formDefaultModel
    builder
    .addCase(getFormDefaultModelAsync.pending, (state) => {
      state.status = 'loading';
    })
    .addCase(getFormDefaultModelAsync.fulfilled, (state, action) => {
      if(action.payload !== null){
        state.status = 'idle';
        state.formDefaultModel = action.payload;
      }
      else{
        state.status = 'failed'
      }
    });

    //create
    builder
      .addCase(createAsync.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(createAsync.fulfilled, (state, action) => {
        if(action.payload !== null){
          state.status = 'idle';
          state.records.push(action.payload);
        }
        else{
          state.status = 'failed';
        }
      });

      //update
      builder
      .addCase(updateAsync.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(updateAsync.fulfilled, (state, action) => {
        if(action.payload !== null){
          state.status = 'idle';
          state.records = state.records.filter(x => x.id !== action.payload.id);
          state.selectedRecords = state.selectedRecords.filter(x => x.id !== action.payload.id);
          state.records.push(action.payload);
        }
        else{
          state.status = 'failed';
        }
      });

      //delete
      builder
      .addCase(deleteAsync.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(deleteAsync.fulfilled, (state, action) => {
        if(action.payload !== null){
          state.status = 'idle';
          state.records = state.records.filter(x => x.id !== action.payload.id);
          state.selectedRecords = state.selectedRecords.filter(x => x.id !== action.payload.id);
        }
        else{
          state.status = 'failed';
        }
      });
      
  },
});


export const { addSelectedRecord, delSelectedRecord, clearSelectedRecords, setFilter } = playerSlice.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
export const selectAll = (state: RootState) => state.player.records;
export const selectById = (state: RootState, id: string) => state.player.records.filter(x=> x.id === id)[0] ?? { id: Constants.GUID_EMPTY};
export const selectIsSelected = (state: RootState, record:Model) => state.player.selectedRecords.filter(x => x.id === record.id).length !== 0;
export const selectFormDefaultModel = (state: RootState) => state.player.formDefaultModel;

export const selectAllInTeam = (state: RootState, teamId: string) => state.player.records.filter(x => x.teamEntityId === teamId);

export const selectFirstSelectedRecord = (state: RootState) => state.player.selectedRecords[0];
export const selectSelectedRecords = (state: RootState) => state.player.selectedRecords;

export const selectFilter = (state: RootState) => state.player.filter;

export const selectIsAnyRecordSelected = (state: RootState) => state.player.selectedRecords.length !== 0;
export const selectIsOneRecordSelected = (state: RootState) =>  state.player.selectedRecords.length === 1;

export const selectIsLoading = (state: RootState) => state.player.status === 'loading';
export const selectIsFetched = (state: RootState) => state.player.status !== 'notFetched';

export default playerSlice.reducer;
