import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';
import { RootState, AppThunk } from '../../../app/store';
import TournamentVenueClient from '../../../api/tournamentVenueClient';
import Model from '../../../models/api/Model';
import Constants from "../../../utils/Constants";
import TournamentVenue from "../../../models/Entities/TournamentVenue"

export interface TournamentVenueState {
  records: TournamentVenue[];
  selectedRecords: TournamentVenue[];
  formDefaultModel: TournamentVenue,
  status: 'idle' | 'loading' | 'failed' | 'notFetched';
  filter:{
    [key:string]:any,
    global?: string,
    name?: string,
    description?: string,
  }
}

const initialState: TournamentVenueState = {
  records: [],
  selectedRecords: [],
  formDefaultModel: { id: Constants.GUID_EMPTY},
  status: 'notFetched',
  filter: {
    global: "",
    name: "",
    description: "",
  },
};

export const fetchAsync = createAsyncThunk(
  'TournamentVenue/fetch',
  async () => {
    try{
      const response = await TournamentVenueClient.getAll({});
      // The value we return becomes the `fulfilled` action payload
      return response.data;
    }
    catch(exception){
      return null;
    }
  }
);

export const getByIdAsync = createAsyncThunk(
  'TournamentVenue/getById',
  async (id: string) => {
    try{
      const response = await TournamentVenueClient.getById(id);
      // The value we return becomes the `fulfilled` action payload
      return response.data;
    }
    catch(exception){
      return null;
    }
  }
);

export const createAsync = createAsyncThunk(
  'TournamentVenue/create',
  async (payload: any) => {
    try{
      payload.image = payload.imagePath;
      const response = await TournamentVenueClient.create(payload);
      // The value we return becomes the `fulfilled` action payload

      return response.data;
    }
    catch(exception){
      return null;
    }
  }
);

export const getFormDefaultModelAsync = createAsyncThunk(
  'TournamentVenue/getFormDefaultModel',
  async () => {
    try{
      const response = await TournamentVenueClient.getFormDefaultModel();
      // The value we return becomes the `fulfilled` action payload
      return response.data;
    }
    catch{
      return null;
    }
  }
)


export const updateAsync = createAsyncThunk(
  'TournamentVenue/update',
  async (payload: any) => {
    try{
      payload.image = payload.imagePath;
      const response = await TournamentVenueClient.update(payload);
      // The value we return becomes the `fulfilled` action payload
      return response.data;
    }
    catch(exception){
      return null;
    }
  }
);

export const deleteAsync = createAsyncThunk(
  'TournamentVenue/delete',
  async (payload: any) => {
    try{
      await TournamentVenueClient.delete(payload);
      // The value we return becomes the `fulfilled` action payload
      return payload;
    }
    catch(exception){
      return null;
    }
  }
);

export const TournamentVenueSlice = createSlice({
  name: 'TournamentVenue',
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    addSelectedRecord: (state, action: PayloadAction<TournamentVenue>) => {
      state.selectedRecords.push(action.payload);
    },
    delSelectedRecord: (state, action: PayloadAction<TournamentVenue>) => {
      state.selectedRecords = state.selectedRecords.filter(x=> x.id !== action.payload.id);
    },
    clearSelectedRecords: (state) => {
      state.selectedRecords = [];
    },
    setFilter: (state, action: PayloadAction<{field: string, value: any}>) => {
      state.filter[action.payload.field] = action.payload.value;
    }
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    //fetch
    builder
      .addCase(fetchAsync.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(fetchAsync.fulfilled, (state, action) => {
        if(action.payload !== null){
          state.status = 'idle';
          state.records = action.payload;
        }
        else{
          state.status = 'failed'
        }
      });

    //getById
    builder
      .addCase(getByIdAsync.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(getByIdAsync.fulfilled, (state, action) => {
        if(action.payload !== null){
          state.status = 'idle';
          state.records = state.records.filter(x => x.id !== action.payload.id);
          
          state.records.push(action.payload);
          state.selectedRecords.push(action.payload);
        }
        else{
          state.status = 'failed'
        }
      });

    //formDefaultModel
    builder
    .addCase(getFormDefaultModelAsync.pending, (state) => {
      state.status = 'loading';
    })
    .addCase(getFormDefaultModelAsync.fulfilled, (state, action) => {
      if(action.payload !== null){
        state.status = 'idle';
        state.formDefaultModel = action.payload;
      }
      else{
        state.status = 'failed'
      }
    });

    //create
    builder
      .addCase(createAsync.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(createAsync.fulfilled, (state, action) => {
        if(action.payload !== null){
          state.status = 'idle';
          state.records.push(action.payload);
        }
        else{
          state.status = 'failed';
        }
      });

      //update
      builder
      .addCase(updateAsync.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(updateAsync.fulfilled, (state, action) => {
        if(action.payload !== null){
          state.status = 'idle';
          state.records = state.records.filter(x => x.id !== action.payload.id);
          state.selectedRecords = state.selectedRecords.filter(x => x.id !== action.payload.id);
          state.records.push(action.payload);
        }
        else{
          state.status = 'failed';
        }
      });

      //delete
      builder
      .addCase(deleteAsync.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(deleteAsync.fulfilled, (state, action) => {
        if(action.payload !== null){
          state.status = 'idle';
          state.records = state.records.filter(x => x.id !== action.payload.id);
          state.selectedRecords = state.selectedRecords.filter(x => x.id !== action.payload.id);
        }
        else{
          state.status = 'failed';
        }
      });
      
  },
});


export const { addSelectedRecord, delSelectedRecord, clearSelectedRecords, setFilter } = TournamentVenueSlice.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
export const selectAll = (state: RootState) => state.tournamentVenue.records;
export const selectById = (state: RootState, id: string) => state.tournamentVenue.records.filter(x=> x.id === id)[0] ?? { id: Constants.GUID_EMPTY};
export const selectIsSelected = (state: RootState, record:Model) => state.tournamentVenue.selectedRecords.filter(x => x.id === record.id).length !== 0;
export const selectFormDefaultModel = (state: RootState) => state.tournamentVenue.formDefaultModel;

export const selectFirstSelectedRecord = (state: RootState) => state.tournamentVenue.selectedRecords[0];
export const selectSelectedRecords = (state: RootState) => state.tournamentVenue.selectedRecords;

export const selectIsAnyRecordSelected = (state: RootState) => state.tournamentVenue.selectedRecords.length !== 0;
export const selectIsOneRecordSelected = (state: RootState) => state.tournamentVenue.selectedRecords.length === 1;

export const selectFilter = (state: RootState) => state.tournamentVenue.filter;

export const selectIsLoading = (state: RootState) => state.tournamentVenue.status === 'loading';
export const selectIsFetched = (state: RootState) => state.tournamentVenue.status !== 'notFetched';

export default TournamentVenueSlice.reducer;
